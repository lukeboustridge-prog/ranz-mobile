---
phase: 13-offline-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/background-sync.ts
  - src/types/database.ts
  - src/lib/sqlite.ts
autonomous: true

must_haves:
  truths:
    - "Background sync uses expo-background-task API (not deprecated expo-background-fetch)"
    - "Sync queue items have idempotency keys preventing duplicate uploads"
    - "Idempotency key format includes entity ID + operation + timestamp"
  artifacts:
    - path: "src/services/background-sync.ts"
      provides: "Modern background sync using expo-background-task"
      contains: "BackgroundTask"
    - path: "src/types/database.ts"
      provides: "Updated sync_queue schema with idempotency_key column"
      contains: "idempotency_key"
    - path: "src/lib/sqlite.ts"
      provides: "Idempotency key generation and duplicate checking"
      exports: ["addToSyncQueue", "checkIdempotencyKey"]
  key_links:
    - from: "src/services/background-sync.ts"
      to: "expo-background-task"
      via: "import and task registration"
      pattern: "BackgroundTask\\.define"
    - from: "src/lib/sqlite.ts"
      to: "sync_queue"
      via: "INSERT with idempotency check"
      pattern: "INSERT.*sync_queue.*idempotency_key"
---

<objective>
Migrate background sync to modern expo-background-task API and add idempotency keys to prevent duplicate uploads.

Purpose: The current expo-background-fetch is deprecated and will be removed in upcoming Expo releases. Idempotency keys ensure that network retries don't create duplicate records on the server.

Output: Updated background-sync.ts using new API, sync_queue schema with idempotency_key column, SQLite functions with duplicate prevention.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-offline-sync/13-RESEARCH.md

@src/services/background-sync.ts
@src/lib/sqlite.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate background-sync.ts to expo-background-task</name>
  <files>src/services/background-sync.ts</files>
  <action>
Replace expo-background-fetch with expo-background-task API:

1. Update imports:
   - Remove: `import * as BackgroundFetch from "expo-background-fetch"`
   - Add: `import * as BackgroundTask from "expo-background-task"`
   - Keep: `import * as TaskManager from "expo-task-manager"`

2. Update task definition:
   - Replace `BackgroundFetch.BackgroundFetchResult` with `BackgroundTask.BackgroundTaskResult`
   - Keep the same task logic (network check, pending reports check, sync call)
   - Update return values to use BackgroundTask.BackgroundTaskResult enum

3. Update registration function:
   - Replace `BackgroundFetch.registerTaskAsync` with `BackgroundTask.registerTaskAsync`
   - Keep same options: `minimumInterval`, `stopOnTerminate`, `startOnBoot`
   - Note: expo-background-task uses same interval semantics

4. Update status functions:
   - Replace `BackgroundFetch.getStatusAsync` with `BackgroundTask.getStatusAsync`
   - Replace `BackgroundFetch.BackgroundFetchStatus` with `BackgroundTask.BackgroundTaskStatus`
   - Update `BackgroundSyncStatus` interface if enum names changed

5. Update unregister function:
   - Replace `BackgroundFetch.unregisterTaskAsync` with `BackgroundTask.unregisterTaskAsync`

6. Keep all logging and sync logic unchanged - only the API layer changes.

IMPORTANT: The SDK 54 package is `expo-background-task` (check package.json - if not present, add install note in summary). The API is nearly identical to expo-background-fetch but uses WorkManager on Android and BGTaskScheduler on iOS.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/services/background-sync.ts
```
Check that BackgroundTask is imported correctly.
  </verify>
  <done>
background-sync.ts uses expo-background-task API with BackgroundTask.define, BackgroundTask.registerTaskAsync, and BackgroundTask.BackgroundTaskResult types. No references to expo-background-fetch remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency_key column to sync_queue schema</name>
  <files>src/types/database.ts</files>
  <action>
Update the sync_queue table schema and LocalSyncQueue type:

1. Find the sync_queue CREATE TABLE statement (around line 652) and add:
   ```sql
   idempotency_key TEXT NOT NULL UNIQUE,
   ```
   Place it after `entity_id` column.

2. Add a migration comment explaining this is a schema migration:
   ```sql
   -- Migration: Added idempotency_key column for deduplication
   -- Key format: {entity_type}:{entity_id}:{operation}:{timestamp_ms}
   ```

3. Update the LocalSyncQueue interface (find it in the types section):
   ```typescript
   export interface LocalSyncQueue {
     id: number;
     entityType: string;
     entityId: string;
     operation: string;
     payloadJson: string;
     createdAt: string;
     attemptCount: number;
     lastError: string | null;
     idempotencyKey: string; // NEW: unique key for deduplication
   }
   ```

4. Add index for idempotency_key (after existing sync_queue indexes around line 693-694):
   ```sql
   CREATE UNIQUE INDEX IF NOT EXISTS idx_sync_queue_idempotency ON sync_queue(idempotency_key);
   ```

NOTE: The actual migration will be handled by SQLite's "CREATE TABLE IF NOT EXISTS" and we'll add an ALTER TABLE migration in sqlite.ts for existing databases.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/types/database.ts
```
  </verify>
  <done>
LocalSyncQueue interface includes idempotencyKey field. Schema string includes idempotency_key column with UNIQUE constraint and index.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update sqlite.ts with idempotency key functions</name>
  <files>src/lib/sqlite.ts</files>
  <action>
Update sync queue functions to use idempotency keys:

1. Add migration for existing databases (near the initDatabase function):
   ```typescript
   // Migration: Add idempotency_key column to existing sync_queue tables
   async function migrateAddIdempotencyKey(): Promise<void> {
     const database = getDatabase();
     try {
       // Check if column exists
       const tableInfo = await database.getAllAsync<{ name: string }>(
         "PRAGMA table_info(sync_queue)"
       );
       const hasColumn = tableInfo.some(col => col.name === 'idempotency_key');

       if (!hasColumn) {
         console.log('[SQLite] Migrating sync_queue: adding idempotency_key column');
         // Add column with default (existing rows get timestamp-based keys)
         await database.runAsync(
           "ALTER TABLE sync_queue ADD COLUMN idempotency_key TEXT"
         );
         // Backfill existing rows with generated keys
         await database.runAsync(
           `UPDATE sync_queue SET idempotency_key = entity_type || ':' || entity_id || ':' || operation || ':' || CAST(strftime('%s', created_at) AS TEXT) || '000' WHERE idempotency_key IS NULL`
         );
         // Create unique index
         await database.runAsync(
           "CREATE UNIQUE INDEX IF NOT EXISTS idx_sync_queue_idempotency ON sync_queue(idempotency_key)"
         );
       }
     } catch (error) {
       console.error('[SQLite] Migration error:', error);
     }
   }
   ```

2. Add idempotency key generator function:
   ```typescript
   /**
    * Generate an idempotency key for sync queue items
    * Format: {entityType}:{entityId}:{operation}:{timestampMs}
    */
   export function generateIdempotencyKey(
     entityType: string,
     entityId: string,
     operation: string
   ): string {
     return `${entityType}:${entityId}:${operation}:${Date.now()}`;
   }
   ```

3. Add check function:
   ```typescript
   /**
    * Check if an idempotency key already exists in the queue
    */
   export async function checkIdempotencyKey(idempotencyKey: string): Promise<boolean> {
     const database = getDatabase();
     const result = await database.getFirstAsync<{ count: number }>(
       "SELECT COUNT(*) as count FROM sync_queue WHERE idempotency_key = ?",
       [idempotencyKey]
     );
     return (result?.count ?? 0) > 0;
   }
   ```

4. Update addToSyncQueue function (around line 1218-1224):
   ```typescript
   export async function addToSyncQueue(
     entityType: string,
     entityId: string,
     operation: string,
     payload: Record<string, unknown>,
     idempotencyKey?: string // Optional - generate if not provided
   ): Promise<boolean> {
     const key = idempotencyKey || generateIdempotencyKey(entityType, entityId, operation);
     const database = getDatabase();

     try {
       await database.runAsync(
         `INSERT INTO sync_queue (entity_type, entity_id, operation, payload_json, created_at, attempt_count, idempotency_key)
          VALUES (?, ?, ?, ?, ?, 0, ?)`,
         [entityType, entityId, operation, JSON.stringify(payload), new Date().toISOString(), key]
       );
       return true;
     } catch (error) {
       // UNIQUE constraint violation = duplicate key = skip
       if (error instanceof Error && error.message.includes('UNIQUE constraint')) {
         console.log(`[SQLite] Duplicate sync queue item skipped: ${key}`);
         return false;
       }
       throw error;
     }
   }
   ```

5. Update getSyncQueue function (around line 1227) to include idempotencyKey in results:
   ```typescript
   return results.map((row) => ({
     id: row.id as number,
     entityType: row.entity_type as string,
     entityId: row.entity_id as string,
     operation: row.operation as string,
     payloadJson: row.payload_json as string,
     createdAt: row.created_at as string,
     attemptCount: row.attempt_count as number,
     lastError: row.last_error as string | null,
     idempotencyKey: row.idempotency_key as string, // NEW
   }));
   ```

6. Call migrateAddIdempotencyKey() in initDatabase after the main schema creation.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/lib/sqlite.ts
```
Check that generateIdempotencyKey and checkIdempotencyKey are exported.
  </verify>
  <done>
sqlite.ts exports generateIdempotencyKey and checkIdempotencyKey functions. addToSyncQueue accepts optional idempotency key and handles duplicates gracefully. getSyncQueue returns idempotencyKey field. Migration adds column to existing databases.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for all modified files
2. background-sync.ts imports from expo-background-task (not expo-background-fetch)
3. LocalSyncQueue interface has idempotencyKey field
4. generateIdempotencyKey function exists and returns format: {type}:{id}:{op}:{ts}
5. addToSyncQueue returns false (not throws) for duplicate keys
</verification>

<success_criteria>
- expo-background-task API used throughout background-sync.ts
- Idempotency keys generated for all new sync queue items
- Duplicate queue items are silently rejected (UNIQUE constraint)
- Migration handles existing databases without data loss
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-offline-sync/13-01-SUMMARY.md`
</output>
