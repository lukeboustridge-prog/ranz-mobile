---
phase: 13-offline-sync
plan: 04
type: execute
wave: 3
depends_on: ["13-03"]
files_modified:
  - src/components/ConflictModal.tsx
  - src/components/SyncStatusBar.tsx
  - src/hooks/useSyncEngine.ts
autonomous: true

must_haves:
  truths:
    - "User sees conflict modal when sync detects concurrent edits"
    - "Conflict modal shows 'Keep Mine', 'Keep Server', 'View Differences' options"
    - "User can manually retry failed sync items from sync status UI"
    - "Sync status bar shows pending count and failed count"
  artifacts:
    - path: "src/components/ConflictModal.tsx"
      provides: "Modal for resolving sync conflicts"
      exports: ["ConflictModal"]
    - path: "src/components/SyncStatusBar.tsx"
      provides: "Sync status indicator with retry button"
      exports: ["SyncStatusBar"]
    - path: "src/hooks/useSyncEngine.ts"
      provides: "Hook with conflict and retry state"
      exports: ["useSyncEngine"]
  key_links:
    - from: "src/components/ConflictModal.tsx"
      to: "src/hooks/useSyncEngine.ts"
      via: "resolveConflict callback prop"
      pattern: "onResolve.*resolution"
    - from: "src/components/SyncStatusBar.tsx"
      to: "src/hooks/useSyncEngine.ts"
      via: "retry failed callback"
      pattern: "onRetryFailed|retryFailed"
---

<objective>
Create conflict resolution UI and manual retry functionality for sync operations.

Purpose: When concurrent edits occur (user edits locally while server version changes), users need a clear way to resolve conflicts. Failed sync items should be visible and retryable without requiring a full app restart.

Output: ConflictModal component for resolving sync conflicts. SyncStatusBar component showing sync status with retry button. Updated useSyncEngine hook with conflict and retry state.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-offline-sync/13-RESEARCH.md
@.planning/phases/13-offline-sync/13-03-SUMMARY.md

@src/hooks/useSyncEngine.ts
@src/services/sync-service.ts
@src/lib/sqlite.ts
@src/lib/theme.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConflictModal component</name>
  <files>src/components/ConflictModal.tsx</files>
  <action>
Create a modal component for resolving sync conflicts:

```typescript
/**
 * ConflictModal
 * Displays when sync detects concurrent edits, allowing user to choose resolution
 */

import React from 'react';
import {
  Modal,
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
} from 'react-native';
import { colors, spacing, typography } from '../lib/theme';

export interface SyncConflict {
  reportId: string;
  reportNumber: string;
  resolution: 'client_wins' | 'server_wins' | 'pending';
  serverUpdatedAt: string;
  clientUpdatedAt: string;
}

export type ConflictResolution = 'keep_local' | 'keep_server' | 'dismiss';

interface ConflictModalProps {
  visible: boolean;
  conflicts: SyncConflict[];
  onResolve: (reportId: string, resolution: ConflictResolution) => void;
  onDismissAll: () => void;
}

export function ConflictModal({
  visible,
  conflicts,
  onResolve,
  onDismissAll,
}: ConflictModalProps) {
  if (conflicts.length === 0) return null;

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={onDismissAll}
    >
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.title}>Sync Conflicts</Text>
          <Text style={styles.subtitle}>
            {conflicts.length} report{conflicts.length !== 1 ? 's' : ''} changed on server while you were editing
          </Text>
        </View>

        <ScrollView style={styles.conflictList}>
          {conflicts.map((conflict) => (
            <View key={conflict.reportId} style={styles.conflictItem}>
              <Text style={styles.reportNumber}>
                {conflict.reportNumber || 'New Report'}
              </Text>
              <Text style={styles.conflictInfo}>
                Your edit: {formatDate(conflict.clientUpdatedAt)}
              </Text>
              <Text style={styles.conflictInfo}>
                Server edit: {formatDate(conflict.serverUpdatedAt)}
              </Text>

              <View style={styles.buttonRow}>
                <TouchableOpacity
                  style={[styles.button, styles.keepLocalButton]}
                  onPress={() => onResolve(conflict.reportId, 'keep_local')}
                >
                  <Text style={styles.buttonText}>Keep Mine</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.button, styles.keepServerButton]}
                  onPress={() => onResolve(conflict.reportId, 'keep_server')}
                >
                  <Text style={styles.buttonText}>Keep Server</Text>
                </TouchableOpacity>
              </View>
            </View>
          ))}
        </ScrollView>

        <View style={styles.footer}>
          <TouchableOpacity
            style={styles.dismissButton}
            onPress={onDismissAll}
          >
            <Text style={styles.dismissButtonText}>Dismiss All (Decide Later)</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

function formatDate(isoString: string): string {
  try {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);

    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
    return date.toLocaleDateString();
  } catch {
    return isoString;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
  },
  header: {
    padding: spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: colors.border,
  },
  title: {
    fontSize: typography.sizes.xl,
    fontWeight: typography.weights.bold as '700',
    color: colors.text,
    marginBottom: spacing.xs,
  },
  subtitle: {
    fontSize: typography.sizes.sm,
    color: colors.textSecondary,
  },
  conflictList: {
    flex: 1,
    padding: spacing.md,
  },
  conflictItem: {
    backgroundColor: colors.surface,
    borderRadius: 12,
    padding: spacing.md,
    marginBottom: spacing.md,
    borderWidth: 1,
    borderColor: colors.warning,
  },
  reportNumber: {
    fontSize: typography.sizes.lg,
    fontWeight: typography.weights.semibold as '600',
    color: colors.text,
    marginBottom: spacing.sm,
  },
  conflictInfo: {
    fontSize: typography.sizes.sm,
    color: colors.textSecondary,
    marginBottom: spacing.xs,
  },
  buttonRow: {
    flexDirection: 'row',
    marginTop: spacing.md,
    gap: spacing.sm,
  },
  button: {
    flex: 1,
    paddingVertical: spacing.sm,
    paddingHorizontal: spacing.md,
    borderRadius: 8,
    alignItems: 'center',
  },
  keepLocalButton: {
    backgroundColor: colors.primary,
  },
  keepServerButton: {
    backgroundColor: colors.secondary,
  },
  buttonText: {
    color: colors.white,
    fontWeight: typography.weights.medium as '500',
    fontSize: typography.sizes.sm,
  },
  footer: {
    padding: spacing.lg,
    borderTopWidth: 1,
    borderTopColor: colors.border,
  },
  dismissButton: {
    paddingVertical: spacing.md,
    alignItems: 'center',
  },
  dismissButtonText: {
    color: colors.textSecondary,
    fontSize: typography.sizes.md,
  },
});

export default ConflictModal;
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/components/ConflictModal.tsx
```
  </verify>
  <done>
ConflictModal.tsx exports ConflictModal component with SyncConflict and ConflictResolution types. Modal shows conflict list with 'Keep Mine' and 'Keep Server' buttons for each conflict.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncStatusBar component</name>
  <files>src/components/SyncStatusBar.tsx</files>
  <action>
Create a status bar component showing sync state with retry functionality:

```typescript
/**
 * SyncStatusBar
 * Shows current sync status with pending/failed counts and retry button
 */

import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { colors, spacing, typography } from '../lib/theme';

interface SyncStatusBarProps {
  isOnline: boolean;
  isSyncing: boolean;
  pendingCount: number;
  failedCount: number;
  lastSyncAt: string | null;
  onRetryFailed: () => void;
  onSync: () => void;
}

export function SyncStatusBar({
  isOnline,
  isSyncing,
  pendingCount,
  failedCount,
  lastSyncAt,
  onRetryFailed,
  onSync,
}: SyncStatusBarProps) {
  const hasIssues = failedCount > 0;
  const hasPending = pendingCount > 0;

  return (
    <View style={[styles.container, !isOnline && styles.offline]}>
      {/* Connection Status */}
      <View style={styles.statusSection}>
        <View style={[styles.statusDot, isOnline ? styles.online : styles.offlineDot]} />
        <Text style={styles.statusText}>
          {isOnline ? 'Online' : 'Offline'}
        </Text>
      </View>

      {/* Sync State */}
      {isSyncing ? (
        <View style={styles.syncingSection}>
          <ActivityIndicator size="small" color={colors.primary} />
          <Text style={styles.syncingText}>Syncing...</Text>
        </View>
      ) : (
        <View style={styles.countsSection}>
          {hasPending && (
            <View style={styles.countBadge}>
              <Text style={styles.countText}>{pendingCount} pending</Text>
            </View>
          )}
          {hasIssues && (
            <TouchableOpacity
              style={[styles.countBadge, styles.failedBadge]}
              onPress={onRetryFailed}
            >
              <Text style={[styles.countText, styles.failedText]}>
                {failedCount} failed - Tap to retry
              </Text>
            </TouchableOpacity>
          )}
        </View>
      )}

      {/* Sync Button */}
      {isOnline && !isSyncing && (
        <TouchableOpacity
          style={styles.syncButton}
          onPress={onSync}
          disabled={!hasPending && !hasIssues}
        >
          <Text style={[
            styles.syncButtonText,
            (!hasPending && !hasIssues) && styles.syncButtonDisabled
          ]}>
            Sync Now
          </Text>
        </TouchableOpacity>
      )}

      {/* Last Sync */}
      {lastSyncAt && !isSyncing && (
        <Text style={styles.lastSyncText}>
          Last: {formatLastSync(lastSyncAt)}
        </Text>
      )}
    </View>
  );
}

function formatLastSync(isoString: string): string {
  try {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);

    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
    return date.toLocaleDateString();
  } catch {
    return 'Unknown';
  }
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.surface,
    paddingVertical: spacing.sm,
    paddingHorizontal: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: colors.border,
    gap: spacing.md,
  },
  offline: {
    backgroundColor: colors.errorLight || '#FEE2E2',
  },
  statusSection: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  online: {
    backgroundColor: colors.success,
  },
  offlineDot: {
    backgroundColor: colors.error,
  },
  statusText: {
    fontSize: typography.sizes.sm,
    color: colors.textSecondary,
  },
  syncingSection: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
    flex: 1,
  },
  syncingText: {
    fontSize: typography.sizes.sm,
    color: colors.primary,
  },
  countsSection: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
    flex: 1,
  },
  countBadge: {
    backgroundColor: colors.primaryLight || '#E0E7FF',
    paddingVertical: 2,
    paddingHorizontal: spacing.sm,
    borderRadius: 12,
  },
  failedBadge: {
    backgroundColor: colors.errorLight || '#FEE2E2',
  },
  countText: {
    fontSize: typography.sizes.xs,
    color: colors.primary,
  },
  failedText: {
    color: colors.error,
  },
  syncButton: {
    paddingVertical: spacing.xs,
    paddingHorizontal: spacing.sm,
  },
  syncButtonText: {
    fontSize: typography.sizes.sm,
    color: colors.primary,
    fontWeight: typography.weights.medium as '500',
  },
  syncButtonDisabled: {
    color: colors.textMuted,
  },
  lastSyncText: {
    fontSize: typography.sizes.xs,
    color: colors.textMuted,
  },
});

export default SyncStatusBar;
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/components/SyncStatusBar.tsx
```
  </verify>
  <done>
SyncStatusBar.tsx exports SyncStatusBar component showing online/offline status, pending count, failed count with retry tap, and sync button. Failed items badge is tappable to trigger retry.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update useSyncEngine hook with conflict and retry state</name>
  <files>src/hooks/useSyncEngine.ts</files>
  <action>
Update the hook to manage conflicts, failed counts, and retry functionality:

1. Add imports:
   ```typescript
   import { getFailedSyncCount, resetFailedItems } from "../lib/sqlite";
   import { retryFailedSyncs } from "../services/sync-service";
   import type { SyncConflict, ConflictResolution } from "../components/ConflictModal";
   ```

2. Add state for conflicts and failed count:
   ```typescript
   const [conflicts, setConflicts] = useState<SyncConflict[]>([]);
   const [showConflictModal, setShowConflictModal] = useState(false);
   const [failedCount, setFailedCount] = useState(0);
   ```

3. Register conflict callback in useEffect (add to existing useEffect):
   ```typescript
   syncEngine.onConflict((serverConflicts) => {
     // Transform server conflicts to our format
     const formatted: SyncConflict[] = serverConflicts.map((c) => ({
       reportId: c.reportId,
       reportNumber: '', // Will be populated from report data
       resolution: c.resolution as 'client_wins' | 'server_wins' | 'pending',
       serverUpdatedAt: (c as any).serverUpdatedAt || new Date().toISOString(),
       clientUpdatedAt: (c as any).clientUpdatedAt || new Date().toISOString(),
     }));
     setConflicts(formatted);
     if (formatted.length > 0) {
       setShowConflictModal(true);
     }
   });
   ```

4. Add function to load failed count:
   ```typescript
   const loadFailedCount = useCallback(async () => {
     try {
       const count = await getFailedSyncCount();
       setFailedCount(count);
     } catch (error) {
       console.error('[Sync] Failed to load failed count:', error);
     }
   }, []);
   ```

5. Call loadFailedCount in loadSyncState and after sync:
   ```typescript
   const loadSyncState = useCallback(async () => {
     try {
       const state = await getSyncState();
       setSyncState(state);
       await loadFailedCount(); // ADD
     } catch (error) {
       console.error("[Sync] Failed to load sync state:", error);
     }
   }, [loadFailedCount]);
   ```

6. Add retry function:
   ```typescript
   const retryFailed = useCallback(async () => {
     try {
       // Reset failed items in database
       await resetFailedItems();

       // Trigger sync
       const result = await retryFailedSyncs();
       setLastResult(result);

       // Reload counts
       await loadSyncState();
     } catch (error) {
       console.error('[Sync] Retry failed:', error);
     }
   }, [loadSyncState]);
   ```

7. Add conflict resolution function:
   ```typescript
   const resolveConflict = useCallback((reportId: string, resolution: ConflictResolution) => {
     // Remove from conflicts list
     setConflicts((prev) => prev.filter((c) => c.reportId !== reportId));

     // TODO: Send resolution to server in future phase
     console.log(`[Sync] Conflict resolved for ${reportId}: ${resolution}`);

     // Close modal if no more conflicts
     if (conflicts.length <= 1) {
       setShowConflictModal(false);
     }
   }, [conflicts.length]);

   const dismissConflicts = useCallback(() => {
     setShowConflictModal(false);
   }, []);
   ```

8. Update return value:
   ```typescript
   return {
     syncState: {
       ...syncState,
       isOnline: isConnected,
     },
     progress,
     lastResult,
     sync,
     refresh: loadSyncState,
     // NEW: Conflict management
     conflicts,
     showConflictModal,
     resolveConflict,
     dismissConflicts,
     // NEW: Failed items
     failedCount,
     retryFailed,
   };
   ```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/hooks/useSyncEngine.ts
```
  </verify>
  <done>
useSyncEngine hook exports conflicts, showConflictModal, resolveConflict, dismissConflicts, failedCount, and retryFailed. Hook registers conflict callback on sync engine and loads failed count.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for all files
2. ConflictModal renders conflict list with resolution buttons
3. SyncStatusBar shows online/offline, pending, failed counts
4. useSyncEngine returns conflicts array and resolution functions
5. retryFailed resets failed items and triggers sync
6. Failed badge in SyncStatusBar is tappable
</verification>

<success_criteria>
- Conflict modal shows when sync returns conflicts
- User can choose 'Keep Mine' or 'Keep Server' for each conflict
- Sync status bar shows pending and failed counts
- Tapping failed count triggers retry
- Components use project theme colors and spacing
</success_criteria>

<output>
After completion, create `.planning/phases/13-offline-sync/13-04-SUMMARY.md`
</output>
