---
phase: 13-offline-sync
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/services/sync-service.ts
  - src/lib/sqlite.ts
  - src/services/evidence-service.ts
autonomous: true

must_haves:
  truths:
    - "Failed sync items retry with exponential backoff up to MAX_RETRY_ATTEMPTS"
    - "Items exceeding max attempts are marked as 'permanently_failed'"
    - "Evidence hash is verified against original after successful sync"
    - "Hash mismatch triggers VERIFIED custody event with failure status"
  artifacts:
    - path: "src/services/sync-service.ts"
      provides: "Retry queue logic with max attempts"
      contains: "MAX_RETRY_ATTEMPTS"
    - path: "src/lib/sqlite.ts"
      provides: "Functions for retry queue management"
      exports: ["getRetryableItems", "markPermanentlyFailed"]
    - path: "src/services/evidence-service.ts"
      provides: "Post-sync hash verification"
      exports: ["verifySyncedEvidence"]
  key_links:
    - from: "src/services/sync-service.ts"
      to: "src/lib/sqlite.ts"
      via: "getRetryableItems call"
      pattern: "getRetryableItems"
    - from: "uploadPhotoToPresignedUrl"
      to: "verifySyncedEvidence"
      via: "call after successful upload and custody log"
      pattern: "verifySyncedEvidence.*photoId"
---

<objective>
Implement retry queue with max attempts and post-sync hash verification for evidence integrity.

Purpose: Reliable sync requires intelligent retry logic that doesn't drain battery on permanently failed items. Post-sync hash verification ensures evidence integrity is maintained throughout the upload process - critical for legal admissibility.

Output: Retry queue with exponential backoff and max attempts. Evidence hash verification after successful sync with custody logging of verification result.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-offline-sync/13-RESEARCH.md
@.planning/phases/13-offline-sync/13-01-SUMMARY.md
@.planning/phases/13-offline-sync/13-02-SUMMARY.md

@src/services/sync-service.ts
@src/lib/sqlite.ts
@src/services/evidence-service.ts
@src/services/chain-of-custody.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry queue management functions to sqlite.ts</name>
  <files>src/lib/sqlite.ts</files>
  <action>
Add functions to manage retry queue with max attempts:

1. Add constants at the top of the file (after imports):
   ```typescript
   export const MAX_SYNC_RETRY_ATTEMPTS = 5;
   export const PERMANENTLY_FAILED_STATUS = 'permanently_failed';
   ```

2. Add function to get retryable items (items that haven't exceeded max attempts):
   ```typescript
   /**
    * Get sync queue items that are still eligible for retry
    * Excludes items that have exceeded MAX_SYNC_RETRY_ATTEMPTS
    */
   export async function getRetryableItems(): Promise<LocalSyncQueue[]> {
     const database = getDatabase();
     const results = await database.getAllAsync<Record<string, unknown>>(
       `SELECT * FROM sync_queue
        WHERE attempt_count < ?
        ORDER BY created_at ASC`,
       [MAX_SYNC_RETRY_ATTEMPTS]
     );

     return results.map((row) => ({
       id: row.id as number,
       entityType: row.entity_type as string,
       entityId: row.entity_id as string,
       operation: row.operation as string,
       payloadJson: row.payload_json as string,
       createdAt: row.created_at as string,
       attemptCount: row.attempt_count as number,
       lastError: row.last_error as string | null,
       idempotencyKey: row.idempotency_key as string,
     }));
   }
   ```

3. Add function to mark items as permanently failed:
   ```typescript
   /**
    * Mark a sync queue item as permanently failed (exceeded max retries)
    * These items will need manual intervention to retry
    */
   export async function markPermanentlyFailed(id: number, finalError: string): Promise<void> {
     const database = getDatabase();
     await database.runAsync(
       `UPDATE sync_queue
        SET last_error = ?,
            operation = operation || ':' || ?
        WHERE id = ?`,
       [finalError, PERMANENTLY_FAILED_STATUS, id]
     );
   }
   ```

4. Add function to get failed items count:
   ```typescript
   /**
    * Get count of permanently failed sync items
    */
   export async function getFailedSyncCount(): Promise<number> {
     const database = getDatabase();
     const result = await database.getFirstAsync<{ count: number }>(
       `SELECT COUNT(*) as count FROM sync_queue
        WHERE attempt_count >= ? OR operation LIKE ?`,
       [MAX_SYNC_RETRY_ATTEMPTS, '%:' + PERMANENTLY_FAILED_STATUS]
     );
     return result?.count ?? 0;
   }
   ```

5. Add function to reset failed items for manual retry:
   ```typescript
   /**
    * Reset permanently failed items for manual retry
    * Called when user explicitly requests retry
    */
   export async function resetFailedItems(): Promise<number> {
     const database = getDatabase();
     const result = await database.runAsync(
       `UPDATE sync_queue
        SET attempt_count = 0,
            last_error = NULL,
            operation = REPLACE(operation, ':' || ?, '')
        WHERE attempt_count >= ? OR operation LIKE ?`,
       [PERMANENTLY_FAILED_STATUS, MAX_SYNC_RETRY_ATTEMPTS, '%:' + PERMANENTLY_FAILED_STATUS]
     );
     return result.changes;
   }
   ```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/lib/sqlite.ts
```
Check exports:
```bash
grep -E "export (async )?function (getRetryableItems|markPermanentlyFailed|getFailedSyncCount|resetFailedItems)" src/lib/sqlite.ts
```
  </verify>
  <done>
sqlite.ts exports getRetryableItems, markPermanentlyFailed, getFailedSyncCount, and resetFailedItems functions. MAX_SYNC_RETRY_ATTEMPTS constant is exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add post-sync hash verification to evidence-service</name>
  <files>src/services/evidence-service.ts</files>
  <action>
Add function to verify evidence hash after sync:

1. Add import for chain-of-custody (if not already present):
   ```typescript
   import { logVerification } from "./chain-of-custody";
   ```

2. Add import for getUser from sqlite:
   ```typescript
   import { getUser } from "../lib/sqlite";
   ```

3. Add verification function:
   ```typescript
   /**
    * Verify evidence integrity after sync
    * Compares current file hash against originalHash stored at capture time
    *
    * @param entityType - Type of evidence (photo, video, voice_note)
    * @param entityId - ID of the evidence
    * @param originalHash - Hash computed at capture time
    * @param fileUri - Local URI of the original file
    * @returns Verification result with isValid flag
    */
   export async function verifySyncedEvidence(
     entityType: 'photo' | 'video' | 'voice_note',
     entityId: string,
     originalHash: string,
     fileUri: string
   ): Promise<{ isValid: boolean; currentHash: string; error?: string }> {
     try {
       // Re-compute hash of the original file
       const currentHash = await generateHash(fileUri);

       // Compare with original
       const isValid = currentHash === originalHash;

       // Log verification result to chain of custody
       try {
         const user = await getUser();
         const userId = user?.id ?? 'system';
         const userName = user?.name ?? 'System Verification';

         await logVerification(
           entityType,
           entityId,
           userId,
           userName,
           isValid,
           originalHash,
           currentHash
         );
       } catch (logError) {
         console.warn(`[Evidence] Failed to log verification for ${entityId}:`, logError);
       }

       if (!isValid) {
         console.error(
           `[Evidence] INTEGRITY FAILURE: ${entityType} ${entityId} ` +
           `expected ${originalHash.substring(0, 8)}..., got ${currentHash.substring(0, 8)}...`
         );
       }

       return {
         isValid,
         currentHash,
         error: isValid ? undefined : 'Hash mismatch - file may have been modified',
       };
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : 'Verification failed';
       console.error(`[Evidence] Verification error for ${entityType} ${entityId}:`, error);

       return {
         isValid: false,
         currentHash: '',
         error: errorMessage,
       };
     }
   }
   ```

4. Export the function in the module exports.

Note: This assumes generateHash function already exists in evidence-service.ts. If it's named differently (like computeHash or calculateHash), use that name instead.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/services/evidence-service.ts
```
Check export:
```bash
grep "export.*verifySyncedEvidence" src/services/evidence-service.ts
```
  </verify>
  <done>
evidence-service.ts exports verifySyncedEvidence function that re-computes file hash, compares with original, and logs VERIFIED custody event with pass/fail result.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate retry logic and hash verification into sync-service</name>
  <files>src/services/sync-service.ts</files>
  <action>
Update sync-service to use retry queue and verify evidence after sync:

1. Add imports:
   ```typescript
   import {
     // ... existing imports ...
     getRetryableItems,
     markPermanentlyFailed,
     MAX_SYNC_RETRY_ATTEMPTS,
   } from "../lib/sqlite";
   import { verifySyncedEvidence } from "./evidence-service";
   ```

2. Update the photo upload success handler (around line 850) to add hash verification:
   After the logCustodySync call, before `return true;`:
   ```typescript
   // Verify evidence integrity after sync
   if (photo.originalHash) {
     // Use the original file URI (in originals/ directory)
     const originalUri = photo.localUri.replace('/photos/', '/evidence/originals/orig_');
     const verification = await verifySyncedEvidence(
       'photo',
       photoId,
       photo.originalHash,
       originalUri
     );
     if (!verification.isValid) {
       console.error(`[Sync] Photo ${photoId} failed post-sync verification: ${verification.error}`);
       // Note: We don't fail the sync, but the verification is logged
     }
   }
   ```

3. Add retry handling method to SyncEngine class:
   ```typescript
   /**
    * Calculate exponential backoff delay with jitter
    */
   private calculateBackoff(attemptCount: number): number {
     const baseDelay = 1000; // 1 second
     const maxDelay = 60000; // 1 minute max
     const exponentialDelay = Math.min(baseDelay * Math.pow(2, attemptCount), maxDelay);
     const jitter = Math.random() * 500; // Up to 500ms jitter
     return exponentialDelay + jitter;
   }

   /**
    * Handle sync failure with retry tracking
    */
   private async handleSyncFailure(
     queueItemId: number | undefined,
     entityType: string,
     entityId: string,
     error: string,
     attemptCount: number
   ): Promise<void> {
     if (!queueItemId) return;

     if (attemptCount >= MAX_SYNC_RETRY_ATTEMPTS - 1) {
       // Mark as permanently failed
       await markPermanentlyFailed(queueItemId, error);
       console.warn(
         `[Sync] ${entityType} ${entityId} marked as permanently failed after ${attemptCount + 1} attempts`
       );
     } else {
       // Update attempt count for retry
       await updateSyncQueueAttempt(queueItemId, error);
       console.log(
         `[Sync] ${entityType} ${entityId} will retry (attempt ${attemptCount + 1}/${MAX_SYNC_RETRY_ATTEMPTS})`
       );
     }
   }
   ```

4. Update the photo upload error handler (in the catch block around line 860):
   ```typescript
   } catch (error) {
     console.error(`[Sync] Photo upload error for ${photoId}:`, error);
     const errorMessage = error instanceof Error ? error.message : "Upload error";
     await updatePhotoSyncStatus(photoId, "error", undefined, errorMessage);

     // Track retry attempt (if we have a queue item ID, we'd track it here)
     // For now, the photo's syncStatus = 'error' signals retry eligibility

     return false;
   }
   ```

5. Add similar verification for videos (after successful upload, before return true):
   ```typescript
   // Verify evidence integrity after sync (for videos with originalHash)
   if (video.originalHash) {
     const verification = await verifySyncedEvidence(
       'video',
       video.id,
       video.originalHash,
       video.localUri
     );
     if (!verification.isValid) {
       console.error(`[Sync] Video ${video.id} failed post-sync verification: ${verification.error}`);
     }
   }
   ```

Note: Voice notes are typically small and may not have originalHash in all cases. Add verification conditionally if originalHash exists.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/services/sync-service.ts
```
Check imports:
```bash
grep -E "verifySyncedEvidence|getRetryableItems|markPermanentlyFailed" src/services/sync-service.ts
```
  </verify>
  <done>
sync-service.ts imports and uses retry queue functions. calculateBackoff and handleSyncFailure methods exist. Photo and video uploads verify evidence hash after successful sync. Failed items are tracked with attempt counts.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for all files
2. MAX_SYNC_RETRY_ATTEMPTS = 5 constant exported from sqlite.ts
3. getRetryableItems returns items with attemptCount < MAX_SYNC_RETRY_ATTEMPTS
4. markPermanentlyFailed appends :permanently_failed to operation
5. verifySyncedEvidence logs VERIFIED custody event for all verifications
6. Photo upload verifies hash after sync (with originalUri from originals/ directory)
7. Video upload verifies hash after sync
8. Backoff delay increases exponentially with jitter
</verification>

<success_criteria>
- Sync items retry up to 5 times with exponential backoff
- Items exceeding max attempts are marked as permanently failed
- Evidence hash is verified after every successful upload
- Hash mismatches are logged as VERIFIED:FAILED custody events
- Failed items can be reset for manual retry
</success_criteria>

<output>
After completion, create `.planning/phases/13-offline-sync/13-03-SUMMARY.md`
</output>
