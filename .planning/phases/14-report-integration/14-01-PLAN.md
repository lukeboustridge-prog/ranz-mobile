---
phase: 14-report-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts
  - ../RANZ_Roofing_report/src/app/api/sync/custody-events/route.ts
autonomous: true

must_haves:
  truths:
    - "Web API has endpoint to confirm photo upload after presigned URL upload"
    - "Web API accepts chain of custody events from mobile sync"
    - "Photo URL and thumbnailUrl are updated after upload confirmation"
    - "Hash verification runs server-side after upload confirmation"
  artifacts:
    - path: "../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts"
      provides: "POST endpoint for upload confirmation"
      exports: ["POST"]
    - path: "../RANZ_Roofing_report/src/app/api/sync/custody-events/route.ts"
      provides: "POST endpoint for custody event sync"
      exports: ["POST"]
  key_links:
    - from: "../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts"
      to: "prisma.photo.update"
      via: "database update with URL and hashVerified"
      pattern: "prisma\\.photo\\.update"
    - from: "../RANZ_Roofing_report/src/app/api/sync/custody-events/route.ts"
      to: "prisma.auditLog.createMany"
      via: "bulk insert custody events"
      pattern: "prisma\\.auditLog\\.createMany"
---

<objective>
Create web API endpoints for photo upload confirmation and custody event sync.

Purpose: The mobile app uploads photos to presigned URLs, but the web database photo records have empty URLs until confirmed. Chain of custody events logged on mobile need to sync to the web audit log for court-admissible evidence trails.

Output: Two new API routes in the web app that complete the mobile-to-web integration.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-report-integration/14-RESEARCH.md

# Web app context (work will be done in sibling directory)
# Note: Paths are relative to ranz-mobile, actual work in RANZ_Roofing_report
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create confirm-upload endpoint</name>
  <files>../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts</files>
  <action>
Create POST endpoint at `/api/photos/[id]/confirm-upload` in the web app:

1. Create directory structure:
   ```
   RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts
   ```

2. Implement the endpoint following existing patterns from `/api/photos/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getAuthUser } from "@/lib/auth";
import { uploadToR2, downloadFromR2 } from "@/lib/r2";
import sharp from "sharp";
import crypto from "crypto";

interface ConfirmUploadRequest {
  publicUrl: string;
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const authUser = await getAuthUser(request);
    if (!authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const body: ConfirmUploadRequest = await request.json();

    if (!body.publicUrl) {
      return NextResponse.json(
        { error: "publicUrl is required" },
        { status: 400 }
      );
    }

    // Find the photo and verify ownership
    const photo = await prisma.photo.findUnique({
      where: { id },
      include: { report: true },
    });

    if (!photo) {
      return NextResponse.json({ error: "Photo not found" }, { status: 404 });
    }

    // Verify user has access to this report
    if (photo.report.inspectorId !== authUser.userId) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Skip if already confirmed
    if (photo.url && photo.url !== "") {
      return NextResponse.json({
        success: true,
        message: "Already confirmed",
        photoId: id,
      });
    }

    // Download the uploaded image to verify and generate thumbnail
    const response = await fetch(body.publicUrl);
    if (!response.ok) {
      return NextResponse.json(
        { error: "Failed to fetch uploaded image" },
        { status: 400 }
      );
    }

    const buffer = Buffer.from(await response.arrayBuffer());

    // Verify hash if originalHash exists
    let hashVerified = false;
    if (photo.originalHash) {
      const computedHash = crypto
        .createHash("sha256")
        .update(buffer)
        .digest("hex");
      hashVerified = computedHash === photo.originalHash;

      if (!hashVerified) {
        console.warn(
          `[ConfirmUpload] Hash mismatch for photo ${id}: ` +
          `expected ${photo.originalHash}, got ${computedHash}`
        );
        // Don't fail - log the mismatch but continue
      }
    }

    // Generate thumbnail server-side using Sharp
    const thumbnail = await sharp(buffer)
      .resize(200, 200, { fit: "cover" })
      .jpeg({ quality: 70 })
      .toBuffer();

    // Upload thumbnail to R2
    const thumbnailKey = `thumbnails/${id}.jpg`;
    const thumbnailUrl = await uploadToR2(thumbnail, thumbnailKey, "image/jpeg");

    // Update photo record
    const updatedPhoto = await prisma.photo.update({
      where: { id },
      data: {
        url: body.publicUrl,
        thumbnailUrl,
        hashVerified,
        uploadedAt: new Date(),
      },
    });

    // Create audit log entry
    await prisma.auditLog.create({
      data: {
        reportId: photo.reportId,
        userId: authUser.userId,
        action: "PHOTO_UPLOAD_CONFIRMED",
        details: {
          photoId: id,
          source: "mobile_sync",
          originalHash: photo.originalHash,
          hashVerified,
          thumbnailGenerated: true,
        },
      },
    });

    return NextResponse.json({
      success: true,
      photoId: id,
      url: body.publicUrl,
      thumbnailUrl,
      hashVerified,
    });
  } catch (error) {
    console.error("[ConfirmUpload] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Internal error" },
      { status: 500 }
    );
  }
}
```

3. Key implementation notes:
   - Follow existing auth patterns from other routes in the codebase
   - Use existing `uploadToR2` helper for thumbnail upload
   - Hash verification is logged but doesn't fail the request (fail-safe)
   - Idempotent: already-confirmed photos return success
  </action>
  <verify>
```bash
cd ../RANZ_Roofing_report && npx tsc --noEmit src/app/api/photos/[id]/confirm-upload/route.ts
```
Check that the file compiles and exports POST function.
  </verify>
  <done>
POST /api/photos/[id]/confirm-upload endpoint exists, accepts publicUrl, updates photo with URL and thumbnailUrl, verifies hash, and creates audit log entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create custody-events sync endpoint</name>
  <files>../RANZ_Roofing_report/src/app/api/sync/custody-events/route.ts</files>
  <action>
Create POST endpoint at `/api/sync/custody-events` in the web app:

1. Create the file at:
   ```
   RANZ_Roofing_report/src/app/api/sync/custody-events/route.ts
   ```

2. Implement the endpoint:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getAuthUser } from "@/lib/auth";

// Chain of custody actions from mobile
type CustodyAction =
  | "CAPTURED"
  | "HASHED"
  | "STORED"
  | "SYNCED"
  | "ANNOTATED"
  | "ACCESSED"
  | "EXPORTED"
  | "VERIFIED"
  | "INTEGRITY_CHECK";

interface CustodyEventSync {
  entityType: "photo" | "video" | "voice_note";
  entityId: string;
  action: CustodyAction;
  timestamp: string;
  deviceId: string;
  hashAtTime: string | null;
  details?: string;
}

interface CustodyEventsRequest {
  events: CustodyEventSync[];
  deviceId: string;
  syncTimestamp: string;
}

export async function POST(request: NextRequest) {
  try {
    const authUser = await getAuthUser(request);
    if (!authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body: CustodyEventsRequest = await request.json();

    if (!body.events || !Array.isArray(body.events)) {
      return NextResponse.json(
        { error: "events array is required" },
        { status: 400 }
      );
    }

    if (body.events.length === 0) {
      return NextResponse.json({
        success: true,
        synced: 0,
        message: "No events to sync",
      });
    }

    // Get all unique entity IDs to find their report IDs
    const photoIds = body.events
      .filter((e) => e.entityType === "photo")
      .map((e) => e.entityId);
    const videoIds = body.events
      .filter((e) => e.entityType === "video")
      .map((e) => e.entityId);
    const voiceNoteIds = body.events
      .filter((e) => e.entityType === "voice_note")
      .map((e) => e.entityId);

    // Fetch report IDs for each entity type
    const [photos, videos, voiceNotes] = await Promise.all([
      photoIds.length > 0
        ? prisma.photo.findMany({
            where: { id: { in: photoIds } },
            select: { id: true, reportId: true },
          })
        : [],
      videoIds.length > 0
        ? prisma.video.findMany({
            where: { id: { in: videoIds } },
            select: { id: true, reportId: true },
          })
        : [],
      voiceNoteIds.length > 0
        ? prisma.voiceNote.findMany({
            where: { id: { in: voiceNoteIds } },
            select: { id: true, reportId: true },
          })
        : [],
    ]);

    // Build entity -> reportId map
    const entityToReportId = new Map<string, string>();
    photos.forEach((p) => entityToReportId.set(p.id, p.reportId));
    videos.forEach((v) => entityToReportId.set(v.id, v.reportId));
    voiceNotes.forEach((vn) => entityToReportId.set(vn.id, vn.reportId));

    // Build audit log entries
    const auditLogEntries = body.events
      .filter((event) => entityToReportId.has(event.entityId))
      .map((event) => ({
        reportId: entityToReportId.get(event.entityId)!,
        userId: authUser.userId,
        action: `CUSTODY_${event.action}` as const,
        timestamp: new Date(event.timestamp),
        details: {
          entityType: event.entityType,
          entityId: event.entityId,
          deviceId: event.deviceId,
          hashAtTime: event.hashAtTime,
          mobileDetails: event.details,
          source: "mobile_sync",
          originalTimestamp: event.timestamp,
        },
      }));

    // Bulk insert audit logs
    if (auditLogEntries.length > 0) {
      await prisma.auditLog.createMany({
        data: auditLogEntries,
        skipDuplicates: true, // Prevent duplicate custody events
      });
    }

    const skipped = body.events.length - auditLogEntries.length;

    return NextResponse.json({
      success: true,
      synced: auditLogEntries.length,
      skipped,
      message: skipped > 0
        ? `${skipped} events skipped (entity not found)`
        : "All events synced",
    });
  } catch (error) {
    console.error("[CustodyEvents] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Internal error" },
      { status: 500 }
    );
  }
}
```

3. Implementation notes:
   - Bulk insert with skipDuplicates for idempotency
   - Preserve original mobile timestamps in details
   - Map mobile CustodyAction to server audit log action format
   - Handle missing entities gracefully (skip, don't fail)
  </action>
  <verify>
```bash
cd ../RANZ_Roofing_report && npx tsc --noEmit src/app/api/sync/custody-events/route.ts
```
Check that the file compiles and exports POST function.
  </verify>
  <done>
POST /api/sync/custody-events endpoint exists, accepts array of custody events, maps them to audit log entries preserving timestamps and device info, and handles duplicates gracefully.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for both new route files
2. confirm-upload route accepts POST with publicUrl body parameter
3. confirm-upload generates thumbnail and updates photo record
4. custody-events route accepts POST with events array
5. custody-events preserves original timestamps from mobile
6. Both routes require authentication
</verification>

<success_criteria>
- `/api/photos/[id]/confirm-upload` endpoint functional
- `/api/sync/custody-events` endpoint functional
- Photo URL updated after upload confirmation
- Thumbnail generated server-side after confirmation
- Hash verified and result stored (but doesn't fail request)
- Custody events synced to audit log with original timestamps
- All routes handle errors gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/14-report-integration/14-01-SUMMARY.md`
</output>
