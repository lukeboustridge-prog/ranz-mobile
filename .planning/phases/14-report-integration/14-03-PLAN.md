---
phase: 14-report-integration
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - ../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts
  - ../RANZ_Roofing_report/src/lib/photo-processing.ts
autonomous: true

must_haves:
  truths:
    - "Server computes SHA-256 hash of uploaded photo binary"
    - "Hash comparison result stored in hashVerified field"
    - "Thumbnail generated from uploaded photo on server"
    - "Hash mismatch logged to audit trail but doesn't fail request"
  artifacts:
    - path: "../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts"
      provides: "Hash verification integrated into confirm-upload"
      contains: "createHash"
    - path: "../RANZ_Roofing_report/src/lib/photo-processing.ts"
      provides: "Extracted photo processing utilities"
      exports: ["generateThumbnail", "computePhotoHash"]
  key_links:
    - from: "../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts"
      to: "crypto.createHash"
      via: "SHA-256 hash computation"
      pattern: "createHash\\('sha256'\\)"
    - from: "../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts"
      to: "sharp"
      via: "thumbnail generation"
      pattern: "sharp\\(.*\\)\\.resize"
---

<objective>
Enhance server-side hash verification and thumbnail generation for mobile photo uploads.

Purpose: Evidence integrity requires server verification of the SHA-256 hash computed on mobile at capture time. Thumbnails must be generated server-side since mobile uploads raw photos to presigned URLs.

Output: Enhanced confirm-upload endpoint with robust hash verification and photo processing utilities.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-report-integration/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create photo-processing utility module</name>
  <files>../RANZ_Roofing_report/src/lib/photo-processing.ts</files>
  <action>
Create a reusable photo processing module in the web app:

1. Create file at `RANZ_Roofing_report/src/lib/photo-processing.ts`:

```typescript
/**
 * Photo Processing Utilities
 * Server-side photo processing for mobile uploads
 */

import sharp from "sharp";
import crypto from "crypto";

/**
 * Thumbnail configuration
 */
export const THUMBNAIL_CONFIG = {
  width: 200,
  height: 200,
  fit: "cover" as const,
  quality: 70,
  format: "jpeg" as const,
};

/**
 * Generate a thumbnail from a photo buffer
 * @param buffer - Original photo binary data
 * @param options - Optional override for thumbnail config
 * @returns Thumbnail buffer as JPEG
 */
export async function generateThumbnail(
  buffer: Buffer,
  options?: Partial<typeof THUMBNAIL_CONFIG>
): Promise<Buffer> {
  const config = { ...THUMBNAIL_CONFIG, ...options };

  return sharp(buffer)
    .resize(config.width, config.height, { fit: config.fit })
    .jpeg({ quality: config.quality })
    .toBuffer();
}

/**
 * Compute SHA-256 hash of photo binary
 * @param buffer - Photo binary data
 * @returns Lowercase hex string of SHA-256 hash
 */
export function computePhotoHash(buffer: Buffer): string {
  return crypto.createHash("sha256").update(buffer).digest("hex");
}

/**
 * Verify photo hash matches expected value
 * @param buffer - Photo binary data
 * @param expectedHash - Expected SHA-256 hash from mobile
 * @returns Object with match result and computed hash
 */
export function verifyPhotoHash(
  buffer: Buffer,
  expectedHash: string
): { matches: boolean; computedHash: string } {
  const computedHash = computePhotoHash(buffer);
  return {
    matches: computedHash.toLowerCase() === expectedHash.toLowerCase(),
    computedHash,
  };
}

/**
 * Extract basic image metadata using Sharp
 * @param buffer - Photo binary data
 * @returns Image metadata (width, height, format, size)
 */
export async function extractImageMetadata(buffer: Buffer): Promise<{
  width: number;
  height: number;
  format: string;
  size: number;
}> {
  const metadata = await sharp(buffer).metadata();

  return {
    width: metadata.width || 0,
    height: metadata.height || 0,
    format: metadata.format || "unknown",
    size: buffer.length,
  };
}

/**
 * Process photo for storage
 * Generates thumbnail and computes hash in single pass
 * @param buffer - Original photo binary data
 * @param expectedHash - Optional expected hash for verification
 * @returns Processing result with thumbnail and hash verification
 */
export async function processPhotoForStorage(
  buffer: Buffer,
  expectedHash?: string | null
): Promise<{
  thumbnail: Buffer;
  computedHash: string;
  hashVerified: boolean;
  metadata: {
    width: number;
    height: number;
    format: string;
    size: number;
  };
}> {
  // Run thumbnail generation and metadata extraction in parallel
  const [thumbnail, metadata] = await Promise.all([
    generateThumbnail(buffer),
    extractImageMetadata(buffer),
  ]);

  // Compute hash (synchronous, fast)
  const computedHash = computePhotoHash(buffer);

  // Verify if expected hash provided
  const hashVerified = expectedHash
    ? computedHash.toLowerCase() === expectedHash.toLowerCase()
    : false;

  return {
    thumbnail,
    computedHash,
    hashVerified,
    metadata,
  };
}
```

2. This module consolidates photo processing logic that can be used by:
   - confirm-upload endpoint (primary use)
   - Direct photo upload endpoint (existing)
   - Future batch processing
  </action>
  <verify>
```bash
cd ../RANZ_Roofing_report && npx tsc --noEmit src/lib/photo-processing.ts
```
Check that module exports generateThumbnail, computePhotoHash, verifyPhotoHash, and processPhotoForStorage.
  </verify>
  <done>
photo-processing.ts module created with generateThumbnail, computePhotoHash, verifyPhotoHash, and processPhotoForStorage functions. Configuration constants are exported for consistency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance confirm-upload with robust processing</name>
  <files>../RANZ_Roofing_report/src/app/api/photos/[id]/confirm-upload/route.ts</files>
  <action>
Update the confirm-upload endpoint to use the new photo-processing module:

1. Update imports at the top of the file:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getAuthUser } from "@/lib/auth";
import { uploadToR2 } from "@/lib/r2";
import { processPhotoForStorage } from "@/lib/photo-processing";
```

2. Replace the inline processing logic with the new utility. Update the POST handler body:

```typescript
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const authUser = await getAuthUser(request);
    if (!authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const body = await request.json();

    if (!body.publicUrl) {
      return NextResponse.json(
        { error: "publicUrl is required" },
        { status: 400 }
      );
    }

    // Find the photo and verify ownership
    const photo = await prisma.photo.findUnique({
      where: { id },
      include: { report: true },
    });

    if (!photo) {
      return NextResponse.json({ error: "Photo not found" }, { status: 404 });
    }

    // Verify user has access to this report
    if (photo.report.inspectorId !== authUser.userId) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Skip if already confirmed (idempotent)
    if (photo.url && photo.url !== "") {
      return NextResponse.json({
        success: true,
        message: "Already confirmed",
        photoId: id,
        url: photo.url,
        thumbnailUrl: photo.thumbnailUrl,
        hashVerified: photo.hashVerified,
      });
    }

    // Download the uploaded image
    const response = await fetch(body.publicUrl);
    if (!response.ok) {
      console.error(
        `[ConfirmUpload] Failed to fetch photo ${id} from ${body.publicUrl}: ${response.status}`
      );
      return NextResponse.json(
        { error: "Failed to fetch uploaded image" },
        { status: 400 }
      );
    }

    const buffer = Buffer.from(await response.arrayBuffer());

    // Process photo: generate thumbnail, compute hash, extract metadata
    const processingResult = await processPhotoForStorage(
      buffer,
      photo.originalHash
    );

    // Log hash verification result
    if (photo.originalHash && !processingResult.hashVerified) {
      console.warn(
        `[ConfirmUpload] Hash mismatch for photo ${id}:\n` +
        `  Expected: ${photo.originalHash}\n` +
        `  Computed: ${processingResult.computedHash}`
      );
    }

    // Upload thumbnail to R2
    const thumbnailKey = `thumbnails/${id}.jpg`;
    const thumbnailUrl = await uploadToR2(
      processingResult.thumbnail,
      thumbnailKey,
      "image/jpeg"
    );

    // Update photo record
    const updatedPhoto = await prisma.photo.update({
      where: { id },
      data: {
        url: body.publicUrl,
        thumbnailUrl,
        hashVerified: processingResult.hashVerified,
        uploadedAt: new Date(),
        // Optionally update dimensions if not set
        ...(photo.width === null && {
          width: processingResult.metadata.width,
          height: processingResult.metadata.height,
        }),
      },
    });

    // Create audit log entry with detailed info
    await prisma.auditLog.create({
      data: {
        reportId: photo.reportId,
        userId: authUser.userId,
        action: "PHOTO_UPLOAD_CONFIRMED",
        details: {
          photoId: id,
          source: "mobile_sync",
          originalHash: photo.originalHash,
          computedHash: processingResult.computedHash,
          hashVerified: processingResult.hashVerified,
          thumbnailGenerated: true,
          fileSize: processingResult.metadata.size,
          dimensions: {
            width: processingResult.metadata.width,
            height: processingResult.metadata.height,
          },
        },
      },
    });

    return NextResponse.json({
      success: true,
      photoId: id,
      url: body.publicUrl,
      thumbnailUrl,
      hashVerified: processingResult.hashVerified,
      metadata: {
        width: processingResult.metadata.width,
        height: processingResult.metadata.height,
        size: processingResult.metadata.size,
      },
    });
  } catch (error) {
    console.error("[ConfirmUpload] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Internal error" },
      { status: 500 }
    );
  }
}
```

3. Key improvements:
   - Uses processPhotoForStorage for consistent processing
   - Hash comparison logged in detail when mismatch occurs
   - Audit log includes both expected and computed hashes
   - Response includes metadata for debugging
   - Idempotent: returns existing data if already confirmed
  </action>
  <verify>
```bash
cd ../RANZ_Roofing_report && npx tsc --noEmit src/app/api/photos/[id]/confirm-upload/route.ts
```
Verify import of processPhotoForStorage and that hashVerified is set from processing result.
  </verify>
  <done>
confirm-upload endpoint uses processPhotoForStorage utility. Hash verification compares mobile originalHash with server-computed hash. Mismatch is logged with both values but doesn't fail request. Thumbnail generated and uploaded to R2. Audit log includes complete verification details.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for both files
2. photo-processing.ts exports all utility functions
3. confirm-upload uses processPhotoForStorage instead of inline logic
4. Hash verification result is accurate (true only if hashes match)
5. Thumbnail is 200x200 JPEG at 70% quality
6. Audit log captures both originalHash and computedHash
</verification>

<success_criteria>
- photo-processing module is reusable across endpoints
- Hash verification is robust (case-insensitive comparison)
- Thumbnail generation uses consistent config
- Hash mismatch is logged with full details
- All processing happens in single pass for efficiency
- Error handling is comprehensive
</success_criteria>

<output>
After completion, create `.planning/phases/14-report-integration/14-03-SUMMARY.md`
</output>
