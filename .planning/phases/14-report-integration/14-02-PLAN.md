---
phase: 14-report-integration
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/services/sync-service.ts
  - src/lib/sqlite.ts
autonomous: true

must_haves:
  truths:
    - "Mobile calls confirm-upload endpoint after successful presigned URL upload"
    - "Custody events are synced to web server after photo upload"
    - "Failed confirmations are queued for retry"
  artifacts:
    - path: "src/services/sync-service.ts"
      provides: "Updated sync engine with upload confirmation and custody sync"
      contains: "confirmPhotoUpload"
    - path: "src/lib/sqlite.ts"
      provides: "Function to get unsynced custody events"
      exports: ["getUnsyncedCustodyEvents", "markCustodyEventsSynced"]
  key_links:
    - from: "src/services/sync-service.ts"
      to: "/api/photos/[id]/confirm-upload"
      via: "POST request after presigned upload"
      pattern: "apiClient\\.post.*confirm-upload"
    - from: "src/services/sync-service.ts"
      to: "/api/sync/custody-events"
      via: "POST request with custody events array"
      pattern: "apiClient\\.post.*custody-events"
---

<objective>
Update mobile sync service to call the new web API endpoints after photo upload.

Purpose: After uploading a photo to a presigned URL, the mobile app must notify the server to update the photo record with the public URL and trigger thumbnail generation. Custody events must also sync for court-admissible evidence trail.

Output: Updated sync-service.ts with confirm-upload call and custody event sync, plus SQLite helpers for tracking synced custody events.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-report-integration/14-RESEARCH.md

@src/services/sync-service.ts
@src/lib/sqlite.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add custody event sync helpers to SQLite</name>
  <files>src/lib/sqlite.ts</files>
  <action>
Add functions to track and retrieve unsynced custody events:

1. Add a `synced_to_server` column tracking to audit_log table. First, add a migration check:

```typescript
/**
 * Migration: Add synced_to_server column to audit_log table
 */
async function migrateAddAuditLogSyncedColumn(): Promise<void> {
  const database = getDatabase();
  try {
    const tableInfo = await database.getAllAsync<{ name: string }>(
      "PRAGMA table_info(audit_log)"
    );
    const hasColumn = tableInfo.some(col => col.name === 'synced_to_server');

    if (!hasColumn) {
      console.log('[SQLite] Migrating audit_log: adding synced_to_server column');
      await database.runAsync(
        "ALTER TABLE audit_log ADD COLUMN synced_to_server INTEGER DEFAULT 0"
      );
      // Create index for efficient querying
      await database.runAsync(
        "CREATE INDEX IF NOT EXISTS idx_audit_log_unsynced ON audit_log(synced_to_server) WHERE synced_to_server = 0"
      );
    }
  } catch (error) {
    console.error('[SQLite] Migration error:', error);
  }
}
```

2. Call this migration in initDatabase after other migrations.

3. Add function to get unsynced custody events:

```typescript
/**
 * Get custody events that haven't been synced to the server
 * Returns events for photos, videos, and voice notes
 */
export async function getUnsyncedCustodyEvents(): Promise<Array<{
  id: number;
  entityType: string;
  entityId: string;
  action: string;
  timestamp: string;
  deviceId: string;
  hashAtTime: string | null;
  details: string | null;
}>> {
  const database = getDatabase();

  // Get custody-related actions (from chain-of-custody.ts)
  const custodyActions = [
    'CAPTURED', 'HASHED', 'STORED', 'SYNCED',
    'ANNOTATED', 'ACCESSED', 'EXPORTED', 'VERIFIED', 'INTEGRITY_CHECK'
  ];

  const results = await database.getAllAsync<{
    id: number;
    entity_type: string;
    entity_id: string;
    action: string;
    timestamp: string;
    details_json: string | null;
  }>(
    `SELECT id, entity_type, entity_id, action, timestamp, details_json
     FROM audit_log
     WHERE synced_to_server = 0
       AND action IN (${custodyActions.map(() => '?').join(',')})
     ORDER BY timestamp ASC
     LIMIT 100`,
    custodyActions
  );

  return results.map(row => {
    const details = row.details_json ? JSON.parse(row.details_json) : {};
    return {
      id: row.id,
      entityType: row.entity_type,
      entityId: row.entity_id,
      action: row.action,
      timestamp: row.timestamp,
      deviceId: details.deviceId || '',
      hashAtTime: details.hashAtTime || null,
      details: details.details || null,
    };
  });
}
```

4. Add function to mark events as synced:

```typescript
/**
 * Mark custody events as synced to server
 */
export async function markCustodyEventsSynced(eventIds: number[]): Promise<void> {
  if (eventIds.length === 0) return;

  const database = getDatabase();
  const placeholders = eventIds.map(() => '?').join(',');

  await database.runAsync(
    `UPDATE audit_log SET synced_to_server = 1 WHERE id IN (${placeholders})`,
    eventIds
  );

  console.log(`[SQLite] Marked ${eventIds.length} custody events as synced`);
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/lib/sqlite.ts
```
Check that getUnsyncedCustodyEvents and markCustodyEventsSynced are exported.
  </verify>
  <done>
sqlite.ts exports getUnsyncedCustodyEvents and markCustodyEventsSynced functions. Migration adds synced_to_server column to audit_log table. Unsynced events are limited to 100 per batch.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update sync-service with confirm-upload call</name>
  <files>src/services/sync-service.ts</files>
  <action>
Update the SyncEngine class to call confirm-upload after presigned URL upload:

1. Add import for the new sqlite functions at the top:
```typescript
import {
  // ... existing imports
  getUnsyncedCustodyEvents,
  markCustodyEventsSynced,
} from "../lib/sqlite";
```

2. Add a new private method `confirmPhotoUpload` after the `uploadPhotoToPresignedUrl` method:

```typescript
/**
 * Confirm photo upload with server after successful presigned URL upload
 * This updates the photo record with the public URL and triggers thumbnail generation
 */
private async confirmPhotoUpload(photoId: string, publicUrl: string): Promise<boolean> {
  try {
    const response = await apiClient.post<{ success: boolean; hashVerified?: boolean }>(
      `/api/photos/${photoId}/confirm-upload`,
      { publicUrl }
    );

    if (response.data.success) {
      console.log(`[Sync] Photo ${photoId} upload confirmed with server`);
      if (response.data.hashVerified === false) {
        console.warn(`[Sync] Photo ${photoId} hash verification failed on server`);
      }
      return true;
    }
    return false;
  } catch (error) {
    console.error(`[Sync] Failed to confirm upload for ${photoId}:`, error);
    // Don't throw - server can handle unconfirmed photos later
    return false;
  }
}
```

3. Modify the `uploadPhotoToPresignedUrl` method. After the successful upload block (around line 908-912), add the confirmation call:

```typescript
if (uploadResult.status >= 200 && uploadResult.status < 300) {
  // Extract the public URL (remove query params from presigned URL)
  const publicUrl = uploadUrl.split("?")[0];

  // Call confirm-upload endpoint to update server photo record
  const confirmed = await this.confirmPhotoUpload(photoId, publicUrl);
  if (!confirmed) {
    console.warn(`[Sync] Photo ${photoId} uploaded but confirmation pending`);
    // Still mark as synced locally - confirmation can be retried
  }

  await updatePhotoSyncStatus(photoId, "synced", publicUrl);
  console.log(`[Sync] Photo ${photoId} uploaded successfully`);
  // ... rest of existing code (custody logging, verification)
```

4. Add a new method to sync custody events:

```typescript
/**
 * Sync unsynced custody events to the server
 */
private async syncCustodyEvents(): Promise<{ synced: number; failed: number }> {
  try {
    const events = await getUnsyncedCustodyEvents();

    if (events.length === 0) {
      return { synced: 0, failed: 0 };
    }

    console.log(`[Sync] Syncing ${events.length} custody events to server`);

    const deviceId = await getOrCreateDeviceId();

    const response = await apiClient.post<{ success: boolean; synced: number }>(
      '/api/sync/custody-events',
      {
        events: events.map(e => ({
          entityType: e.entityType,
          entityId: e.entityId,
          action: e.action,
          timestamp: e.timestamp,
          deviceId: e.deviceId || deviceId,
          hashAtTime: e.hashAtTime,
          details: e.details,
        })),
        deviceId,
        syncTimestamp: new Date().toISOString(),
      }
    );

    if (response.data.success) {
      // Mark all events as synced
      await markCustodyEventsSynced(events.map(e => e.id));
      console.log(`[Sync] Synced ${response.data.synced} custody events`);
      return { synced: response.data.synced, failed: 0 };
    }

    return { synced: 0, failed: events.length };
  } catch (error) {
    console.error('[Sync] Failed to sync custody events:', error);
    return { synced: 0, failed: 0 }; // Don't block other sync
  }
}
```

5. Call syncCustodyEvents in the uploadPendingChanges method, after all uploads complete (around line 669 before "Upload complete"):

```typescript
// Sync custody events to server
try {
  const custodyResult = await this.syncCustodyEvents();
  if (custodyResult.synced > 0) {
    console.log(`[Sync] Synced ${custodyResult.synced} custody events`);
  }
} catch (error) {
  console.warn('[Sync] Custody event sync failed (non-blocking):', error);
}

this.emitProgress("Upload complete", 95);
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/services/sync-service.ts
```
Verify that confirmPhotoUpload is called after successful presigned URL upload, and syncCustodyEvents is called at end of uploadPendingChanges.
  </verify>
  <done>
sync-service.ts calls `/api/photos/[id]/confirm-upload` after successful presigned URL upload. Custody events are synced via `/api/sync/custody-events` at the end of each upload cycle. Both operations are non-blocking (failures logged but don't stop sync).
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for all modified files
2. confirmPhotoUpload method exists and calls POST /api/photos/{id}/confirm-upload
3. syncCustodyEvents method exists and calls POST /api/sync/custody-events
4. getUnsyncedCustodyEvents returns events with synced_to_server = 0
5. markCustodyEventsSynced updates synced_to_server to 1
6. Upload flow: presigned upload -> confirmPhotoUpload -> custody sync
</verification>

<success_criteria>
- confirmPhotoUpload called after successful presigned URL upload
- Server receives publicUrl and can update photo record
- Custody events synced in batches (max 100 per sync)
- Synced events marked to prevent re-sync
- Failures are logged but don't block sync completion
- All changes backward-compatible with existing sync flow
</success_criteria>

<output>
After completion, create `.planning/phases/14-report-integration/14-02-SUMMARY.md`
</output>
